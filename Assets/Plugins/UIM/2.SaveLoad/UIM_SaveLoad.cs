using System.Collections;using System.Collections.Generic;using UnityEngine;using Newtonsoft.Json;using System.IO;using UnityEditor;using Sirenix.OdinInspector;/// <summary>/// UIM_SaveLoad类：负责处理游戏内的数据存储与读取/// 包含保存、加载、打开以及删除数据的方法/// 支持泛型以增强灵活性/// </summary>[AddComponentMenu("UIMaster/SaveLoad")][DisallowMultipleComponent]public static class UIM_SaveLoad{    // 存档的默认文件夹名称    private static string fileNme = "SaveData";    /// <summary>    /// 获取本地Json文件的完整路径    /// </summary>    /// <param name="fileName">文件名</param>    /// <param name="pathname">子路径名，可选</param>    /// <returns>返回Json文件的完整路径</returns>    public static string GetJsonFilePath(string fileName, string pathname = "")    {        var path = GetLocalPath(fileNme + pathname);        return Path.Combine(path, $"{fileName}.json");    }    /// <summary>    /// 保存数据到本地Json文件    /// </summary>    /// <typeparam name="T">继承自ScriptableObject的数据类型</typeparam>    /// <param name="data">需要保存的数据</param>    /// <param name="name">文件名</param>    /// <param name="pathName">可选的子路径名</param>    public static void SaveData<T>(T data, string name, string pathName = "") where T : ScriptableObject    {        var path = GetJsonFilePath(name, pathName);            /*string json = JsonConvert.SerializeObject(data);*/                // 修改后（推荐）        string json = JsonConvert.SerializeObject(data, new JsonSerializerSettings        {            ReferenceLoopHandling = ReferenceLoopHandling.Ignore        });                // string json = JsonUtility.ToJson(data);        File.WriteAllText(path, json);        Debug.Log(UIM_DebugManager.Log($"{data.name}数据存储成功！", "成功", "数据"));    }    /// <summary>    /// 加载数据，根据本地Json文件反序列化到ScriptableObject    /// </summary>    /// <typeparam name="T">继承自ScriptableObject且实现IDataLoadable接口的数据类型</typeparam>    /// <param name="data">目标ScriptableObject</param>    /// <param name="name">文件名</param>    /// <param name="pathName">可选的子路径名</param>    public static void LoadData<T>(T data, string name, string pathName = "") where T : ScriptableObject, IDataLoadable    {        var path = GetJsonFilePath(name, pathName);        if (!File.Exists(path))        {            SaveData(data, name);            Debug.LogWarning(UIM_DebugManager.Log($"{data.name}【加载数据】路径并未找到！将直接创建", "错误", "数据"));        }        string json = File.ReadAllText(path);        data.LoadData(json);        Debug.Log(UIM_DebugManager.Log($"{data.name}【加载数据】数据载入成功！", "成功", "数据"));    }    /// <summary>    /// 检查目标数据文件是否存在    /// </summary>    /// <param name="name">文件名</param>    /// <param name="pathName">可选的子路径名</param>    /// <returns>如果文件存在返回true，否则返回false</returns>    public static bool DoesDataExist(string name, string pathName = "")    {        var path = GetJsonFilePath(name, pathName);        return File.Exists(path);    }    /// <summary>    /// 打开存储数据的本地路径    /// </summary>    public static void OpenData()    {        System.Diagnostics.Process.Start(Application.persistentDataPath);    }    /// <summary>    /// 打开指定的数据文件    /// </summary>    /// <param name="name">文件名</param>    /// <param name="pathName">可选的子路径名</param>    public static void OpenData(string name, string pathName = "")    {        var path = GetJsonFilePath(name, pathName);        System.Diagnostics.Process.Start(path);    }    /// <summary>    /// 删除指定的数据文件    /// </summary>    /// <param name="name">文件名</param>    /// <param name="pathName">可选的子路径名</param>    public static void DeleteData(string name, string pathName = "")    {        var path = GetJsonFilePath(name, pathName);        File.Delete(path);        Debug.Log(UIM_DebugManager.Log($"数据已删除！\n{path}", "成功", "数据"));    }    /// <summary>    /// 获取本地路径，如果路径不存在则自动创建    /// </summary>    /// <param name="path">目标路径</param>    /// <returns>返回完整的本地路径</returns>    public static string GetLocalPath(string path)    {        string folderPath = Path.Combine(Application.persistentDataPath, path);        if (!Directory.Exists(folderPath))        {            Directory.CreateDirectory(folderPath);            Debug.Log(UIM_DebugManager.Log($"{folderPath}文件路径已创建并找到", "成功", "数据", false));        }        else        {            Debug.Log(UIM_DebugManager.Log($"{folderPath}文件路径已被找到", "成功", "数据", false));        }        return folderPath;    }}