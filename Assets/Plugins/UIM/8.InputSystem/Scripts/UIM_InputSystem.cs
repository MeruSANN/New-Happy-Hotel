using UnityEngine;using UnityEngine.InputSystem;using UnityEngine.SceneManagement;using System;using Sirenix.OdinInspector;using Unity.VisualScripting;using UnityEngine.Events;namespace UIM.Input{    [AddComponentMenu("UIMaster/InputSystem/InputSystem")][DisallowMultipleComponent]public class UIM_InputSystem : UIM_UniversalManager<UIM_InputSystem>, IManager{        [LabelText("当前控制模式")]    [ReadOnly]    public ControlMode currentMode;    [LabelText("当前使用设备")]    [ReadOnly]    public ControlDevice currentControlDevice;    [LabelText("当前设备类型")]    [ReadOnly]    public GamepadMod currentGamepad;        [ReadOnly]    public ControlMode _previousMode;    [ReadOnly]    public ControlDevice _previousControlDevice;    [ReadOnly]    public GamepadMod _previousGamepad;            private PlayerInput _playerInput;    private UIM_InputTipsPanel _inputTipsPanel;    /// <summary>    /// 输入模式切换事件    /// </summary>    [FoldoutGroup("事件")]    [LabelText("切换控制模式事件")]    public UnityEvent<ControlDevice> OnSwitchControlDevice;    [FoldoutGroup("事件")]    [LabelText("切换输入设备事件")]    public UnityEvent<ControlMode> OnSwitchControlMode;    [FoldoutGroup("事件")]    [LabelText("切换手柄事件")]    public UnityEvent<Gamepad> OnSwitchGamepad;                        #region Unity Lifecycle        public override void OnEnable()    {        base.OnEnable();        InitializeComponents();        SceneManager.sceneLoaded += OnSceneLoaded;        InputSystem.onDeviceChange += OnDeviceChange;    }    public override void OnDisable()    {        InputSystem.onDeviceChange -= OnDeviceChange;        SceneManager.sceneLoaded -= OnSceneLoaded;    }    private void Update()    {        CheckControlMode();        CheckControlDevice();        CheckControllerType();    }    #endregion    #region Initialization    private void InitializeComponents()    {        _inputTipsPanel = UIM_InputTipsPanel.Instance;        _playerInput = GetComponent<PlayerInput>();            // 初始化默认状态        _previousMode = ControlMode.KeyboardMouse;        currentMode = ControlMode.KeyboardMouse;        _previousControlDevice = ControlDevice.Mouse;        currentControlDevice = ControlDevice.Mouse;        _previousGamepad = GamepadMod.NullGamepad;        currentGamepad = Gamepad.current != null ? GamepadMod.Other : GamepadMod.NullGamepad;            // 初始化光标状态        HandleCursorVisibility();            // 初始检测手柄类型        CheckControllerType();    }    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)    {        InitManager();    }    public override void InitManager()    {        // 初始化逻辑可以放在这里    }    #endregion    #region Device & Mode Detection    private void OnDeviceChange(InputDevice device, InputDeviceChange change)    {        switch (change)        {            case InputDeviceChange.Added when device is Gamepad:                _inputTipsPanel.UpdateLinkState("UI/Input/手柄接入提示", ControlMode.Gamepad);                CheckControllerType(); // 设备添加时立即检查类型                break;                        case InputDeviceChange.Removed when device is Gamepad:                _inputTipsPanel.UpdateLinkState("UI/Input/手柄断开提示", ControlMode.Gamepad);                CheckControllerType(); // 设备移除时立即检查类型                break;                        case InputDeviceChange.Reconnected when device is Gamepad:                CheckControllerType(); // 设备重连时检查类型                break;        }    }    /// <summary>    /// 查找控制模式    /// </summary>    private void CheckControlMode()    {        var newMode = DetermineCurrentMode();            if (newMode != currentMode)        {            _previousMode = currentMode;            currentMode = newMode;                    // 处理光标显示状态            HandleCursorVisibility();                    OnSwitchControlMode?.Invoke(currentMode);        }    }    [Header("Cursor Settings")]    [LabelText("在键鼠模式下是否显示光标")]    public bool showCursorInKeyboardMouseMode = true;    [LabelText("在手柄模式下是否隐藏光标")]    public bool hideCursorInGamepadMode = true;    private void HandleCursorVisibility()    {        switch (currentMode)        {            case ControlMode.KeyboardMouse:                Cursor.visible = showCursorInKeyboardMouseMode;                Cursor.lockState = showCursorInKeyboardMouseMode ?                     CursorLockMode.None : CursorLockMode.Locked;                /*Debug.Log($"<color=blue>光标模式为:{Cursor.lockState}</color>");*/                break;                        case ControlMode.Gamepad:                Cursor.visible = !hideCursorInGamepadMode;                Cursor.lockState = hideCursorInGamepadMode ?                     CursorLockMode.Locked : CursorLockMode.None;                /*Debug.Log($"<color=blue>光标模式为:{Cursor.lockState}</color>");*/                break;        }    }            //其实是从playerinput那里拓扑了过来哈哈    private ControlMode DetermineCurrentMode()    {        return _playerInput.currentControlScheme switch        {            "Gamepad" => ControlMode.Gamepad,            "Keyboard&Mouse" => ControlMode.KeyboardMouse,            _ => currentMode // 保持当前模式不变        };    }    private void CheckControlDevice()    {        var newDevice = DetermineCurrentDevice();                if (newDevice != currentControlDevice)        {            _previousControlDevice = currentControlDevice;            currentControlDevice = newDevice;            OnSwitchControlDevice?.Invoke(currentControlDevice);        }    }    private ControlDevice DetermineCurrentDevice()    {        // 手柄优先检测        if (_playerInput.currentControlScheme == "Gamepad")            return ControlDevice.Gamepad;        // 键盘检测        if (Keyboard.current != null && Keyboard.current.anyKey.wasPressedThisFrame)            return ControlDevice.Keyboard;        // 鼠标检测        if (Mouse.current != null &&             (Mouse.current.leftButton.wasPressedThisFrame ||             Mouse.current.rightButton.wasPressedThisFrame ||             Mouse.current.delta.ReadValue() != Vector2.zero))            return ControlDevice.Mouse;        // 无变化则返回当前设备        return currentControlDevice;    }    #endregion    #region 手柄        public void CheckControllerType()    {        // 添加null检查        if (Gamepad.current == null)        {            if (currentGamepad != GamepadMod.NullGamepad)            {                _previousGamepad = currentGamepad;                currentGamepad = GamepadMod.NullGamepad;                OnSwitchGamepad?.Invoke(null);                Debug.Log("当前没有连接手柄");            }            return;        }        string name = Gamepad.current.displayName;        Debug.Log($"查找到的当前设备名为：{name}");        GamepadMod newGamepad = GamepadMod.Other;            if (IsXboxController(name))        {            Debug.Log("This is an Xbox controller.");            newGamepad = GamepadMod.Xbox;        }        else if (IsPS4Controller(name))        {            Debug.Log("This is a PS4 controller.");            newGamepad = GamepadMod.PS4;        }        else        {            Debug.Log("This is an unknown or unsupported controller.");            newGamepad = GamepadMod.Other;        }        // 只有当手柄类型变化时才触发事件        if (newGamepad != currentGamepad)        {            _previousGamepad = currentGamepad;            currentGamepad = newGamepad;            OnSwitchGamepad?.Invoke(Gamepad.current);        }    }    bool IsXboxController(string controllerName)    {        return controllerName.ToLower().Contains("xbox");    }    bool IsPS4Controller(string controllerName)    {        return controllerName.ToLower().Contains("wireless controller");    }    #region 手柄切换功能    public void SwitchToNextGamepad()    {        var gamepads = Gamepad.all;            // 处理无手柄的情况        if (gamepads.Count == 0)        {            Debug.Log("没有连接的手柄");            currentGamepad = GamepadMod.NullGamepad;            return;        }        var currentgamepad = Gamepad.current;        int currentIndex = Gamepad.current != null             ? gamepads.IndexOf(g => g == currentgamepad)  // 使用lambda表达式作为谓词            : -1;        // 计算下一个索引（循环）        int nextIndex = (currentIndex + 1) % gamepads.Count;        // 切换并更新状态        var nextGamepad = gamepads[nextIndex];        InputSystem.EnableDevice(nextGamepad);            currentGamepad = DetermineGamepadType(nextGamepad);        OnSwitchGamepad?.Invoke(nextGamepad);            Debug.Log($"已切换到: {nextGamepad.name} ({currentGamepad})");    }// 辅助方法：根据设备名判断类型    private GamepadMod DetermineGamepadType(Gamepad gamepad)    {        string name = gamepad.displayName;        if (IsXboxController(name)) return GamepadMod.Xbox;        if (IsPS4Controller(name)) return GamepadMod.PS4;        return GamepadMod.Other;    }    /// <summary>    /// 强制切换到指定类型的手柄    /// </summary>    public void SwitchToGamepadType(GamepadMod targetType)    {        foreach (var gamepad in Gamepad.all)        {            string name = gamepad.displayName;            bool isMatch = false;                    switch (targetType)            {                case GamepadMod.Xbox:                    isMatch = IsXboxController(name);                    break;                case GamepadMod.PS4:                    isMatch = IsPS4Controller(name);                    break;                case GamepadMod.Other:                    isMatch = !IsXboxController(name) && !IsPS4Controller(name);                    break;            }                    if (isMatch)            {                InputSystem.EnableDevice(gamepad);                Debug.Log($"已切换到 {targetType} 手柄: {name}");                return;            }        }            Debug.LogWarning($"未找到 {targetType} 类型的手柄");    }    #endregion    #endregion    public static PlayerInput GetPlayerInput()    {        if (Instance.GetComponent<PlayerInput>())        {            return Instance.GetComponent<PlayerInput>();        }        else        {            return default(PlayerInput);        }                   }                public  InputBinding CheckCurrentBindings(InputActionReference actionReference)    {        var playerInput= UIM_InputSystem.Instance.GetComponent<PlayerInput>();        if (playerInput == null || actionReference == null)        {            return default;        }        // 获取当前Control Scheme        string currentControlScheme = playerInput.currentControlScheme;        // 获取InputAction        InputAction action = actionReference.action;        // 获取当前设备        InputDevice currentDevice = playerInput.devices[0]; // 通常第一个是主设备                string x = $"按键查找\n当前Control Scheme: {currentControlScheme}";        // 查找在当前Control Scheme下有效的Binding        foreach (InputBinding binding in action.bindings)        {            // 检查Binding是否属于当前Control Scheme            if (binding.groups.Contains(currentControlScheme))            {                x+=($"\n找到绑定: {binding}");                x+=($"\n绑定路径: {binding.effectivePath}");                x+=($"\n关联的控件: {binding.ToDisplayString()}");                // 获取实际的InputControl                InputControl control = InputSystem.FindControl(binding.effectivePath);                                                /*if (control != null)                {                    Debug.Log(x += ($"\n实际控件: {control.name} 在设备: {control.device.name}"))                ;                }*/                                return binding;                            }        }        return default;    }                }public enum ControlMode{    [InspectorName("键鼠模式")]    KeyboardMouse,        [InspectorName("手柄模式")]    Gamepad}public enum ControlDevice{    [InspectorName("手柄")]    Gamepad,        [InspectorName("键盘")]    Keyboard,        [InspectorName("鼠标")]    Mouse}public enum GamepadMod{    [InspectorName("无手柄")]    NullGamepad,    [InspectorName("Xbox手柄")]    Xbox,    [InspectorName("PS4手柄")]    PS4,    [InspectorName("未知手柄")]    Other}}