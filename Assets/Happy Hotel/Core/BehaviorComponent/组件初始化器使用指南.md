# 组件初始化器使用指南

## 概述

组件初始化器系统是一个基于注册属性的组件自动初始化机制，允许mod开发者和DLC开发者在不修改原有代码的情况下，为特定的容器类型自动添加和初始化组件。

## 系统架构

### 核心组件

1. **ComponentInitializerAttribute** - 注册属性，用于标记组件初始化器
2. **IComponentInitializer** - 初始化器接口，定义初始化器的基本契约
3. **ComponentInitializerRegistry** - 注册表，负责扫描、注册和管理所有初始化器
4. **EntityComponentInitializerAttribute** - EntityComponent的注册属性
5. **IEntityComponentInitializer** - EntityComponent的初始化器接口
6. **EntityComponentInitializerRegistry** - EntityComponent的注册表

## 使用方法

### 1. 创建组件初始化器

为BehaviorComponent创建初始化器：

```csharp
using UnityEngine;
using HappyHotel.Character;
using HappyHotel.Core.BehaviorComponent;
using HappyHotel.Core.ValueProcessing.Components;

namespace MyMod
{
    // 为Player类自动初始化组件的初始化器
    [ComponentInitializer(typeof(Player), typeof(HealthValueComponent), typeof(ArmorValueComponent))]
    public class PlayerModComponentInitializer : IComponentInitializer
    {
        public Type TargetContainerType => typeof(Player);
        
        public void InitializeComponents(BehaviorComponentContainer container)
        {
            // 添加生命值组件
            var healthComponent = container.AddBehaviorComponent<HealthValueComponent>();
            healthComponent.SetMaxHealth(150); // mod特定的生命值
            healthComponent.SetCurrentHealth(150);
            
            // 添加护甲组件
            var armorComponent = container.AddBehaviorComponent<ArmorValueComponent>();
            armorComponent.SetMaxArmor(75); // mod特定的护甲值
            armorComponent.SetCurrentArmor(0);
            
            // 添加mod特定的组件
            var modComponent = container.AddBehaviorComponent<MyModSpecialAbilityComponent>();
            modComponent.Initialize(/* mod参数 */);
            
            Debug.Log($"Player mod组件初始化完成");
        }
    }
}
```

为EntityComponent创建初始化器：

```csharp
using HappyHotel.Core.EntityComponent;
using HappyHotel.Shop;

namespace MyMod
{
    // 为ShopItemManager自动初始化组件的初始化器
    [EntityComponentInitializer(typeof(ShopItemManager), typeof(MyModShopComponent))]
    public class ShopModComponentInitializer : IEntityComponentInitializer
    {
        public Type TargetContainerType => typeof(ShopItemManager);
        
        public void InitializeComponents(EntityComponentContainer container)
        {
            // 添加mod特定的商店组件
            var modShopComponent = container.AddEntityComponent<MyModShopComponent>();
            modShopComponent.Initialize(/* mod参数 */);
            
            Debug.Log($"Shop mod组件初始化完成");
        }
    }
}
```

### 2. 系统自动扫描和注册

组件初始化器系统会在游戏启动时自动扫描所有程序集中带有相应注册属性的类，并自动注册它们。无需手动注册。

### 3. 组件自动初始化

当容器（如Player、Enemy等）的Awake方法被调用时，系统会自动：

1. 执行原有的AutoInitComponentAttribute初始化（向后兼容）
2. 调用所有适用于该容器类型的组件初始化器
3. 支持继承关系，基类的初始化器也会被调用

## 高级用法

### 1. 条件初始化

```csharp
[ComponentInitializer(typeof(Player))]
public class ConditionalPlayerInitializer : IComponentInitializer
{
    public Type TargetContainerType => typeof(Player);
    
    public void InitializeComponents(BehaviorComponentContainer container)
    {
        // 检查mod是否启用
        if (MyModManager.Instance.IsModEnabled)
        {
            var modComponent = container.AddBehaviorComponent<MyModComponent>();
            modComponent.Initialize();
        }
        
        // 检查游戏难度
        if (GameManager.Instance.Difficulty == GameDifficulty.Hard)
        {
            var hardModeComponent = container.AddBehaviorComponent<HardModeComponent>();
            hardModeComponent.Initialize();
        }
    }
}
```

### 2. 依赖注入

```csharp
[ComponentInitializer(typeof(Player))]
public class DependencyInjectionInitializer : IComponentInitializer
{
    public Type TargetContainerType => typeof(Player);
    
    public void InitializeComponents(BehaviorComponentContainer container)
    {
        // 先添加基础组件
        var healthComponent = container.AddBehaviorComponent<HealthValueComponent>();
        
        // 添加依赖基础组件的组件
        var healthRegenerationComponent = container.AddBehaviorComponent<HealthRegenerationComponent>();
        healthRegenerationComponent.SetHealthComponent(healthComponent);
        
        // 添加UI显示组件
        var healthUIComponent = container.AddBehaviorComponent<HealthUIComponent>();
        healthUIComponent.SetHealthComponent(healthComponent);
    }
}
```

### 3. 配置驱动的初始化

```csharp
[ComponentInitializer(typeof(Player))]
public class ConfigDrivenInitializer : IComponentInitializer
{
    public Type TargetContainerType => typeof(Player);
    
    public void InitializeComponents(BehaviorComponentContainer container)
    {
        var config = MyModConfig.Instance;
        
        // 根据配置文件初始化组件
        if (config.EnableHealthRegeneration)
        {
            var regenComponent = container.AddBehaviorComponent<HealthRegenerationComponent>();
            regenComponent.SetRegenerationRate(config.HealthRegenerationRate);
        }
        
        if (config.EnableArmorSystem)
        {
            var armorComponent = container.AddBehaviorComponent<ArmorValueComponent>();
            armorComponent.SetMaxArmor(config.MaxArmor);
        }
    }
}
```

## 最佳实践

### 1. 命名规范

- 初始化器类名：`{目标类型名}ModComponentInitializer`
- 命名空间：使用mod或DLC的专用命名空间
- 文件位置：放在mod或DLC的专用目录中

### 2. 错误处理

```csharp
public void InitializeComponents(BehaviorComponentContainer container)
{
    try
    {
        // 初始化逻辑
        var component = container.AddBehaviorComponent<MyComponent>();
        component.Initialize();
    }
    catch (Exception ex)
    {
        Debug.LogError($"Mod组件初始化失败: {ex.Message}");
        // 不要抛出异常，让系统继续运行
    }
}
```

### 3. 性能考虑

- 避免在初始化器中执行耗时操作
- 使用延迟初始化处理复杂的设置
- 缓存组件引用避免重复查找

### 4. 向后兼容

- 不要移除或修改现有组件的初始化逻辑
- 使用条件检查避免与现有系统冲突
- 提供配置选项让用户选择启用/禁用功能

## 调试和测试

### 1. 查看注册的初始化器

```csharp
// 在游戏运行时查看注册的初始化器数量
int count = ComponentInitializerRegistry.GetInitializerCount();
Debug.Log($"已注册的组件初始化器数量: {count}");
```

### 2. 测试初始化器

```csharp
[UnityTest]
public IEnumerator TestModComponentInitialization()
{
    // 创建测试对象
    var gameObject = new GameObject("TestPlayer");
    var player = gameObject.AddComponent<Player>();
    
    // 等待初始化完成
    yield return null;
    
    // 验证组件是否正确初始化
    var modComponent = player.GetBehaviorComponent<MyModComponent>();
    Assert.IsNotNull(modComponent, "Mod组件应该被正确初始化");
    
    // 清理
    Object.DestroyImmediate(gameObject);
}
```

## 注意事项

1. **编译时安全**：系统在编译时检查类型，IDE会提供智能提示
2. **自动扫描**：无需手动注册，系统自动发现和加载初始化器
3. **继承支持**：支持基类初始化器，子类会自动继承
4. **错误隔离**：单个初始化器出错不会影响其他初始化器
5. **向后兼容**：保留原有的AutoInitComponentAttribute机制

## 总结

组件初始化器系统为mod和DLC开发提供了强大而灵活的组件扩展机制，遵循开闭原则，允许在不修改原有代码的情况下扩展游戏功能。 