## 目标
快速新增一个可被注册与运行的 Intent（含 Intent 类、Setting、Factory、模板资源）。

### 前置
- Intent 体系：`IntentBase`、`IIntentSetting`、`IntentTemplate`
- 注册体系：`IntentRegistrationAttribute`、`IntentFactoryBase<TIntent>`、`IntentRegistry`、`IntentManager`
- Setting 绑定：`[IntentSettingFor("<TypeId>")]` → `IntentSettingTypeLookup`
- 资源加载：模板资源位于 `Assets/Happy Hotel/Intent/Resources/Templates/` 下，由 `IntentResourceManager` 通过 `Resources.Load` 加载
- 新的由 Registry 系统托管的类型，需遵循 `添加新Registry类型指南.md`

## 命名与放置建议
- **TypeId**：全局唯一，建议使用 `PascalCase`，如 `AddSelfArmor`
- **文件路径**：
  - Intent 脚本：`Assets/Happy Hotel/Intent/Scripts/Intents/<Name>.cs`
  - Setting 脚本：`Assets/Happy Hotel/Intent/Scripts/Settings/<Name>Setting.cs`
  - Factory 脚本：`Assets/Happy Hotel/Intent/Scripts/Factories/<Name>Factory.cs`
  - 模板资源：`Assets/Happy Hotel/Intent/Resources/Templates/<Readable Name>.asset`

## 步骤一：编写 Intent 类
- 继承 `IntentBase`
- 覆写 `GetDisplayValue()`（用于 UI 显示数值）
- 实现 `ExecuteAsync()`（执行实际效果）
- 如需使用宿主的行为组件，通过 `owner.GetBehaviorComponent<T>()`

示例（为自身添加护甲）：
```csharp
using HappyHotel.Core.BehaviorComponent;
using HappyHotel.Core.ValueProcessing.Components;
using UnityEngine;
using Cysharp.Threading.Tasks;

namespace HappyHotel.Intent
{
	// 意图：为敌人自身添加护甲（立即生效）
	public class AddSelfArmorIntent : IntentBase
	{
		private int amount;

		public void SetAmount(int value)
		{
			amount = Mathf.Max(0, value);
		}

		public override int GetDisplayValue()
		{
			return amount;
		}

		public override UniTask ExecuteAsync()
		{
			if (owner == null) return UniTask.CompletedTask;
			var armor = owner.GetBehaviorComponent<ArmorValueComponent>();
			if (armor == null) return UniTask.CompletedTask;
			if (amount <= 0) return UniTask.CompletedTask;
			armor.AddArmor(amount, owner);
			return UniTask.CompletedTask;
		}
	}
}
```

## 步骤二：编写 Setting（运行时参数）
- 实现 `IIntentSetting`
- 使用 `[IntentSettingFor("<TypeId>")]` 绑定到意图类型 Id
- 在 `ConfigureIntent` 中把数据写入 Intent 实例

示例：
```csharp
using Sirenix.Serialization;

namespace HappyHotel.Intent.Settings
{
	// Setting：为 AddSelfArmorIntent 提供数值
	[System.Serializable]
	[IntentSettingFor("AddSelfArmor")]
	public class AddSelfArmorSetting : IIntentSetting
	{
		[OdinSerialize]
		public int amount = 1;

		public void ConfigureIntent(IntentBase intent)
		{
			var typed = intent as AddSelfArmorIntent;
			if (typed == null) return;
			typed.SetAmount(amount);
		}
	}
}
```

## 步骤三：编写 Factory（注册 + 创建）
- 继承 `IntentFactoryBase<TIntent>`
- 使用 `[IntentRegistration("<TypeId>", "Templates/<Readable Name>")]` 注册，并指定模板资源路径（`Resources/` 相对路径）

示例：
```csharp
using HappyHotel.Intent.Factories;

namespace HappyHotel.Intent
{
	// 工厂：注册并创建 AddSelfArmorIntent
	[IntentRegistration("AddSelfArmor",
		"Templates/Add Self Armor Intent")]
	public class AddSelfArmorIntentFactory : IntentFactoryBase<AddSelfArmorIntent>
	{
	}
}
```

> 说明：`IntentFactoryBase` 会在创建时自动为 Intent 填充 `TypeId`，并调用 Setting 进行配置。

## 步骤四：创建模板资源（可选但推荐）
- 在 `Assets/Happy Hotel/Intent/Resources/Templates/` 下创建 `IntentTemplate` 资产
- 文件名需与注册时的 `TemplatePath` 对应，例如上例中是 `Add Self Armor Intent`
- 可配置 `icon` 与 `description` 以便 UI 展示

## 验证
- 工厂被自动扫描注册（运行时通过 `IntentRegistry / IntentManager`）
- `IntentSettingTypeLookup` 会按 `TypeId` 找到对应 Setting 类型
- 在 UI/调试中应能看到意图描述与显示值（取决于 `GetDisplayValue()`）

## 常见问题
- 模板加载不到：检查 `TemplatePath` 与资源路径是否一致（不含 `Resources/` 前缀）
- `TypeId` 冲突：确保全局唯一；搜索是否已有同名注册
- 无法获取组件：确认宿主对象上已挂载所需的 Behavior 组件
- 注释风格：仅使用单行注释，不使用 summary 注释
- 新的 Registry 类型：请遵循 `添加新Registry类型指南.md`

## 复用清单（新增一个 Intent 需要做什么）
- 新建 Intent 类，实现显示数值与执行逻辑
- 新建 Setting，使用 `IntentSettingFor` 标注并在 `ConfigureIntent` 中写入参数
- 新建 Factory，使用 `IntentRegistration` 注册 `TypeId` 与模板路径
- 在 `Resources/Templates` 下创建匹配路径的模板资源


