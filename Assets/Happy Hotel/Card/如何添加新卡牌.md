# 如何添加新卡牌

本文档以 `DirectionChangerCard` 为案例，详细说明如何在游戏中添加一个新的卡牌。

## 系统概述

卡牌系统包含以下三个核心组件，按照以下流程工作：
1. **Card** - 卡牌实例，包含卡牌的具体逻辑
2. **Prop** - 地图上的实际道具对象（由卡牌放置产生）
3. **Template** - 配置数据模板

## 完整实现流程

### 第一步：创建模板文件 (Template)

首先需要创建卡牌的配置模板，用于存储卡牌的基础数据。

#### 1.1 基础卡牌模板
```csharp
// 在 Equipment/Scripts/Templates/ 目录下创建
[CreateAssetMenu(fileName = "New Direction Changer Card Template", menuName = "Happy Hotel/Item/Directional Placement Card Template")]
public class DirectionalPlacementCardTemplate : ActivePlacementCardTemplate
{
    [Header("方向设置")]
    [Tooltip("不同方向的指示器图片")]
    public Sprite[] directionSprites;
    
    [Header("可选择方向")]
    [Tooltip("设置卡牌可以选择的方向，支持多选")]
    public DirectionFlags allowedDirections = DirectionFlags.All;
}
```

#### 1.2 特殊卡牌模板（可选）
如果卡牌有特殊需求，可以创建专门的模板类：

```csharp
// 例如：钉刺箭头卡牌模板
[CreateAssetMenu(fileName = "New Spike Arrow Card Template", menuName = "Happy Hotel/Item/Spike Arrow Card Template")]
public class SpikeArrowCardTemplate : DirectionalPlacementCardTemplate
{
    [Header("钉刺箭头设置")]
    [Tooltip("生命值流失数量")]
    public int healthDrainAmount = 2;
    
    [Tooltip("是否自动销毁（触发后销毁）")]
    public bool autoDestroyOnTrigger = true;
}
```

### 第二步：创建 Card 类

Card 是卡牌实例的表示，包含卡牌的具体逻辑。

#### 2.1 基础卡牌类
```csharp
// Assets/Happy Hotel/Card/Scripts/Cards/DirectionChangerCard.cs
using UnityEngine;
using HappyHotel.Prop;
using HappyHotel.Prop.Setting;
using HappyHotel.Equipment.Template;

namespace HappyHotel.Card
{
    // 方向改变卡牌，可以向指定位置放置DirectionChangerProp
    public class DirectionChangerCard : DirectionalPlacementCard
    {
        public override PropBase PlaceProp(Vector2Int position, IPropSetting setting = null)
        {
            if (template == null)
            {
                Debug.LogError("DirectionChangerCard的模板为空");
                return null;
            }

            // 确定要创建的Prop类型ID
            string propTypeIdString = this.TypeId.Id;
            
            // 创建对应的PropTypeId
            var propTypeId = Core.Registry.TypeId.Create<PropTypeId>(propTypeIdString);
            
            // 使用PropController放置道具
            var propController = PropController.Instance;
            if (propController == null)
            {
                Debug.LogError("PropController未初始化");
                return null;
            }

            // 使用传入的设置放置道具
            var prop = propController.PlaceProp(position, propTypeId, setting);
            
            if (prop != null)
            {
                Debug.Log($"成功放置方向改变器道具到位置: {position}");
            }
            else
            {
                Debug.LogError($"无法放置方向改变器道具到位置: {position}");
            }

            return prop;
        }
    }
}
```

#### 2.2 特殊卡牌类
```csharp
// Assets/Happy Hotel/Card/Scripts/Cards/SpikeArrowCard.cs
using UnityEngine;
using HappyHotel.Card;
using HappyHotel.Prop;
using HappyHotel.Prop.Setting;
using HappyHotel.Core;
using HappyHotel.Core.Registry;
using HappyHotel.Equipment.Template;

namespace HappyHotel.Card
{
    // 钉刺箭头卡牌，用于放置钉刺箭头Prop
    public class SpikeArrowCard : DirectionalPlacementCard
    {
        // 获取模板的便捷属性
        protected SpikeArrowCardTemplate SpikeArrowTemplate => template as SpikeArrowCardTemplate;
        
        // 重写PlaceProp方法，放置钉刺箭头Prop
        public override PropBase PlaceProp(Vector2Int position, IPropSetting setting = null)
        {
            // 创建钉刺箭头Prop的TypeId
            var propTypeId = Core.Registry.TypeId.Create<PropTypeId>("SpikeArrowProp");
            
            // 使用PropController放置Prop
            var spikeArrowProp = PropController.Instance.PlaceProp(position, propTypeId, setting) as SpikeArrowProp;
            
            if (spikeArrowProp != null)
            {
                // 从模板读取生命值流失数量
                int drainAmount = SpikeArrowTemplate?.healthDrainAmount ?? 2;
                spikeArrowProp.SetHealthDrainAmount(drainAmount);
                
                Debug.Log($"在位置 {position} 放置了钉刺箭头Prop，流失生命值: {drainAmount}");
            }
            else
            {
                Debug.LogError($"无法在位置 {position} 放置钉刺箭头Prop");
            }
            
            return spikeArrowProp;
        }
        
        // 获取生命值流失数量
        public int GetHealthDrainAmount()
        {
            return SpikeArrowTemplate?.healthDrainAmount ?? 2;
        }
    }
}
```

### 第三步：创建 Prop 类

Prop 是地图上实际的道具对象，包含游戏逻辑。

#### 3.1 基础道具类
```csharp
// Assets/Happy Hotel/Prop/Scripts/Props/DirectionChangerProp.cs
using HappyHotel.Core;
using UnityEngine;
using HappyHotel.Core.BehaviorComponent;
using HappyHotel.Core.Grid.Components;

namespace HappyHotel.Prop
{
    // 方向改变器道具，被触发时改变触发者的方向
    public class DirectionChangerProp : ActivePlaceablePropBase
    {
        public override void OnTriggerInternal(BehaviorComponentContainer triggerer)
        {
            // 获取触发者的方向组件
            var directionComponent = triggerer.GetBehaviorComponent<DirectionComponent>();
            if (directionComponent == null)
            {
                Debug.LogWarning($"{triggerer.gameObject.name} 没有DirectionComponent组件，无法改变方向");
                return;
            }

            // 将触发者的方向设置为道具的方向
            directionComponent.SetDirection(GetDirection());
            
            Debug.Log($"{triggerer.gameObject.name} 的方向被改变为: {GetDirection()}");
        }
    }
}
```

#### 3.2 特殊道具类
```csharp
// Assets/Happy Hotel/Prop/Scripts/Props/SpikeArrowProp.cs
using HappyHotel.Core;
using UnityEngine;
using HappyHotel.Core.BehaviorComponent;
using HappyHotel.Core.Grid.Components;
using HappyHotel.Prop.Components;

namespace HappyHotel.Prop
{
    [AutoInitComponent(typeof(HealthDrainComponent))]
    public class SpikeArrowProp : DirectionChangerProp // 继承方向改变逻辑
    {
        [Header("钉刺箭头设置")]
        [SerializeField] private int healthDrainAmount = 2; // 流失生命值数量
        
        // 组件引用
        private HealthDrainComponent healthDrainComponent;
        
        protected override void Start()
        {
            base.Start();
            
            // 获取组件引用
            healthDrainComponent = GetBehaviorComponent<HealthDrainComponent>();
            
            // 设置生命值流失数量
            if (healthDrainComponent != null)
            {
                healthDrainComponent.SetDrainAmount(healthDrainAmount);
            }
        }
        
        // 重写OnTriggerInternal方法，添加生命值流失逻辑
        public override void OnTriggerInternal(BehaviorComponentContainer triggerer)
        {
            // 先调用父类的方法来改变方向
            base.OnTriggerInternal(triggerer);
            
            // 然后添加生命值流失逻辑
            if (healthDrainComponent != null)
            {
                // 触发HealthDrainComponent的事件处理
                var evt = new BehaviorComponentEvent("Trigger", this, triggerer);
                healthDrainComponent.OnEvent(evt);
            }
        }
        
        // 设置生命值流失数量
        public void SetHealthDrainAmount(int amount)
        {
            healthDrainAmount = Mathf.Max(0, amount);
            if (healthDrainComponent != null)
            {
                healthDrainComponent.SetDrainAmount(healthDrainAmount);
            }
        }
        
        // 获取生命值流失数量
        public int GetHealthDrainAmount()
        {
            return healthDrainAmount;
        }
    }
}
```

### 第四步：创建工厂类

系统中需要为 Card 和 Prop 分别创建对应的工厂类。

#### 4.1 Card 工厂类

Card 工厂负责创建卡牌实例，直接创建 C# 对象，不涉及 GameObject。

```csharp
// Assets/Happy Hotel/Card/Scripts/Factories/DirectionChangerCardFactory.cs
using HappyHotel.Card.Factories;

namespace HappyHotel.Card.Factory
{
    [CardRegistration("DirectionChangerCard", "Templates/Direction Changer Card Template")]
    public class DirectionChangerCardFactory : CardFactoryBase<DirectionChangerCard>
    {
        // 无需重写父类方法
    }
}
```

#### 4.2 Prop 工厂类

Prop 工厂负责创建地图上的实际道具对象，需要创建 GameObject 并添加必要的组件。

```csharp
// Assets/Happy Hotel/Prop/Scripts/Factories/DirectionChangerPropFactory.cs
using HappyHotel.Prop;
using HappyHotel.Prop.Factory;
using HappyHotel.Prop.Setting;
using HappyHotel.Equipment.Template;
using UnityEngine;

namespace HappyHotel.Prop.Factory
{
    [PropRegistration("DirectionChangerCard", "Templates/Direction Changer Card Template")]
    public class DirectionChangerPropFactory : PropFactoryBase<DirectionChangerProp>
    {
        protected override DirectionChangerProp CreatePropComponent(GameObject gameObject)
        {
            return gameObject.AddComponent<DirectionChangerProp>();
        }
    }
}
```

### 第五步：配置 Template 资源文件

#### 5.1 创建卡牌模板资源
在 Unity 编辑器中：
1. 右键点击 `Assets/Happy Hotel/Equipment/Resources/Templates/` 文件夹
2. 选择 `Create > Happy Hotel > Item > Directional Placement Card Template`
3. 命名为 `Direction Changer Card Template`
4. 在 Inspector 中配置：
   - `itemName`: "方向改变器"
   - `description`: "放置一个方向改变器，会改变触发者的方向"
   - `rarity`: Common
   - `cardCost`: 1
   - `isConsumable`: false
   - `autoDestroyOnTrigger`: true
   - `directionSprites`: 设置四个方向的指示器图片
   - `allowedDirections`: All (15)

### 第六步：创建 ShopItem 类（可选）

如果希望卡牌可以在商店中购买，需要创建对应的 ShopItem 类和工厂。

#### 6.1 创建 ShopItem 类

ShopItem 类负责处理卡牌在商店中的购买逻辑。

```csharp
// Assets/Happy Hotel/Shop/Scripts/ShopItems/DirectionChangerCardShopItem.cs
using UnityEngine;
using HappyHotel.Equipment.Template;
using HappyHotel.Card.Setting;

namespace HappyHotel.Shop
{
    // 购买后获得转向器卡牌的商店道具
    public class DirectionChangerCardShopItem : CardShopItemBase
    {
        protected override void OnTemplateSet()
        {
            base.OnTemplateSet();
            // 转向器卡牌不需要额外的数值设置
        }

        protected override string FormatDescriptionInternal(string formattedDescription)
        {
            // 转向器卡牌不需要占位符替换
            return formattedDescription;
        }
    }
}
```

#### 6.2 创建带数值的 ShopItem 类

如果卡牌有数值参数（如护甲数量、伤害提升等），需要创建带数值处理的 ShopItem：

```csharp
// Assets/Happy Hotel/Shop/Scripts/ShopItems/ArmorCardShopItem.cs
using UnityEngine;
using HappyHotel.Equipment.Template;
using HappyHotel.Core.ValueProcessing;
using HappyHotel.Card.Setting;

namespace HappyHotel.Shop
{
    // 购买后获得护甲卡牌的商店道具
    public class ArmorCardShopItem : CardShopItemBase
    {
        // 护甲数量
        [SerializeField] private EquipmentValue armorAmount = new("护甲数量");

        public ArmorCardShopItem()
        {
            armorAmount.Initialize(this);
        }

        public int ArmorAmount => armorAmount;

        public void SetArmorAmount(int newArmorAmount)
        {
            armorAmount.SetBaseValue(Mathf.Max(1, newArmorAmount));
        }

        protected override void OnTemplateSet()
        {
            base.OnTemplateSet();
            // 从护甲卡牌模板中读取护甲数量
            if (template is CardTemplate cardTemplate)
            {
                // 通过反射获取模板中的护甲数量
                var armorAmountField = template.GetType().GetField("armorAmount");
                if (armorAmountField != null)
                {
                    int amount = (int)armorAmountField.GetValue(template);
                    armorAmount.SetBaseValue(amount);
                }
            }
        }

        protected override string FormatDescriptionInternal(string formattedDescription)
        {
            // 为护甲卡牌商店道具添加特定的占位符替换
            return formattedDescription
                .Replace("{armor}", armorAmount.ToString());
        }
    }
}
```

#### 6.3 创建 ShopItem 工厂类

```csharp
// Assets/Happy Hotel/Shop/Scripts/Factories/DirectionChangerCardShopItemFactory.cs
using UnityEngine;

namespace HappyHotel.Shop.Factory
{
    [ShopItemRegistration(
        "DirectionChangerCard",
        "Templates/Direction Changer Card Template")]
    public class DirectionChangerCardShopItemFactory : ShopItemFactoryBase<DirectionChangerCardShopItem>
    {
        protected override DirectionChangerCardShopItem CreateShopItemComponent(GameObject gameObject)
        {
            return gameObject.AddComponent<DirectionChangerCardShopItem>();
        }
    }
}
```

#### 6.4 ShopItem 类型说明

根据卡牌的功能不同，ShopItem 的实现也有所不同：

**简单卡牌**（如转向器）：
- 不需要额外的数值处理
- 不需要占位符替换

**数值卡牌**（如护甲卡牌）：
- 使用 `EquipmentValue` 处理数值
- 通过反射从模板读取初始值
- 实现占位符替换功能

**复合数值卡牌**（如加固防守）：
- 包含多个数值参数
- 分别处理每个数值
- 替换多个占位符

## 关键概念说明

### Template 系统
- **CardTemplate**: 卡牌基础模板，包含卡牌的基本配置
- **ActivePlacementCardTemplate**: 主动放置卡牌模板，继承自CardTemplate
- **DirectionalPlacementCardTemplate**: 方向放置卡牌模板，继承自ActivePlacementCardTemplate
- 模板文件存储在 `Resources/Templates/` 目录下，通过 Unity 的 CreateAssetMenu 创建

### 卡牌类型
系统支持三种卡牌类型，每种类型使用不同的基类和模板：

#### 1. 普通卡牌 (CardBase)
- **基类**: `CardBase`
- **模板基类**: `CardTemplate`
- **特点**: 不需要选择位置，直接使用效果
- **使用场景**: 即时效果卡牌，如治疗、增益等

#### 2. 主动道具放置卡牌 (ActivePlacementCard)
- **基类**: `ActivePlacementCard`
- **模板基类**: `ActivePlacementCardTemplate`
- **特点**: 需要选择位置，放置道具
- **使用场景**: 陷阱、机关等需要选择位置的卡牌

#### 3. 方向放置卡牌 (DirectionalPlacementCard)
- **基类**: `DirectionalPlacementCard`
- **模板基类**: `DirectionalPlacementCardTemplate`
- **特点**: 需要选择位置和方向，放置有方向性的道具
- **使用场景**: 箭头、传送门等有方向性的道具卡牌

### 工厂系统
系统包含三种不同的工厂类型：

- **CardFactory**: 负责创建卡牌实例
  - 继承自 `CardFactoryBase<T>`
  - 使用 `[CardRegistration]` 特性注册
  - 直接创建 C# 对象实例，不涉及 GameObject
  
- **PropFactory**: 负责创建地图上的道具对象
  - 继承自 `PropFactoryBase<T>`
  - 使用 `[PropRegistration]` 特性注册
  - 创建 GameObject 并添加 SpriteRenderer 和 Prop 组件

- **ShopItemFactory**: 负责创建商店道具对象
  - 继承自 `ShopItemFactoryBase<T>`
  - 使用 `[ShopItemRegistration]` 特性注册
  - 创建 GameObject 并添加 ShopItem 组件

### 数据流转
1. **卡牌使用流程**: Card -> PlaceProp() -> PropFactory -> Prop -> 游戏逻辑
2. **商店购买流程**: ShopItem -> CardInventory -> 卡牌背包
3. **配置流程**: Template -> OnTemplateSet() -> 各类属性设置

### 命名约定
- 卡牌类: `DirectionChangerCard`
- 对应的 Prop: `DirectionChangerProp`
- 对应的 ShopItem: `DirectionChangerCardShopItem`
- 对应的工厂类:
  - CardFactory: `DirectionChangerCardFactory`
  - PropFactory: `DirectionChangerPropFactory`
  - ShopItemFactory: `DirectionChangerCardShopItemFactory`
- 对应的 Template: `DirectionalPlacementCardTemplate`

## 注意事项

1. **继承关系**: 所有卡牌类必须继承自对应的基类
2. **Template 设置**: 通过 `OnTemplateSet()` 方法从模板中读取配置
3. **Registry 注册**: 确保所有新类型都正确注册到 Registry 系统
4. **三套工厂**: 每个卡牌都需要创建三套工厂类（Card、Prop、ShopItem），各有不同的注册特性和创建方法
5. **工厂注册特性**: 
   - Card 使用 `[CardRegistration]`
   - Prop 使用 `[PropRegistration]`
   - ShopItem 使用 `[ShopItemRegistration]`
6. **TypeId 一致性**: 确保在所有系统中使用的 TypeId 字符串完全一致
7. **Prop 创建**: 卡牌的 `PlaceProp()` 方法负责创建对应的 Prop 对象
8. **ShopItem 数值处理**: 对于有数值的卡牌，使用 `EquipmentValue` 和反射来处理模板数据

## 最佳实践

1. **模板复用**: 优先使用现有的模板类，避免重复定义
2. **渐进开发**: 先实现基础功能，再添加复杂特性
3. **命名规范**: 严格遵循命名约定，保持代码的可读性和维护性
4. **工厂统一**: 确保三套工厂类使用相同的 TypeId 字符串，保持系统一致性
5. **功能验证**: 确保卡牌、道具和商店功能按预期工作
6. **文档更新**: 添加新卡牌后及时更新相关文档和注释
7. **ShopItem 可选性**: 不是所有卡牌都需要在商店中销售，根据游戏设计决定是否创建 ShopItem

## 完整开发清单

为每个新卡牌创建以下文件：

**基础卡牌**:
- [ ] Template 类（可选，如复用现有模板则跳过）
- [ ] Card 类
- [ ] Prop 类  
- [ ] CardFactory 类
- [ ] PropFactory 类
- [ ] Template 资源文件

**商店功能**（可选）:
- [ ] ShopItem 类
- [ ] ShopItemFactory 类

通过以上步骤，您就可以成功添加一个新卡牌到游戏中。记住要保持命名的一致性，优先考虑模板复用，创建完整的三套工厂类，并确保所有组件都正确实现了必要的接口和方法。 